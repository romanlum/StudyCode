package at.lumetsnet.caas.dal;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.Closeable;
import java.io.IOException;
import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

import at.lumetsnet.caas.model.Entity;

/***
 * Generic dao for JDBC
 * @author romanlum
 *
 * @param <T>
 */
public abstract class GenericJdbcDao<T extends Entity> implements Closeable, GenericDao<T>   {

	protected Connection con;
	protected String conString;
	protected String userName;
	protected String password;
	protected String tableName;
	protected Class<T> entityClass;
	
	
	public GenericJdbcDao(Class<T> entityClass, String tableName, String conString, String userName, String password) {
		this.conString = conString;
		this.userName = userName;
		this.password = password;
		this.tableName = tableName;
		this.entityClass = entityClass;
		
	}

	/***
	 * Gets and opens the connection
	 * @return
	 * @throws DataAccessException
	 */
	public Connection getConnection() throws DataAccessException {
		try
		{
			if(con == null) {
				con = DriverManager.getConnection(conString, userName, password);
			}
			return con;
		}
		catch(SQLException ex) {
			throw new DataAccessException(ex.getMessage());
		}
	}
	
	/***
	 * Closes the connection
	 */
	@Override
	public void close() throws IOException {
		if(con != null) {
			try {
				con.close();
				con = null;
			} catch (SQLException e) {
				throw new DataAccessException(e.getMessage());
			}
		}
	}
	
	
	/***
	 * Inserts or updates an entity based on the id
	 * ID == -1 means new entity
	 * Auto generated id is set after inserting
	 */
	@Override
	public void saveOrUpdate(T entity) {
		if(entity.getId() == -1) {
			try(PreparedStatement stmt = DaoUtil.generateInsertStatement(getConnection(), entity,tableName, getPropertyFilter())) {
				stmt.executeUpdate();
				try(ResultSet rs = stmt.getGeneratedKeys()) {
					if(rs!=null && rs.next()) {
						entity.setId(rs.getInt(1));
					} else {
						throw new DataAccessException("Autogenerated keys are not supported by db");
					}
				}
			} catch(Exception ex){
				throw new DataAccessException(ex.getMessage());
			}
		} else {
			try(PreparedStatement stmt = DaoUtil.generateUpdateStatement(getConnection(), entity,tableName, getPropertyFilter())) {
				stmt.executeUpdate();
			} catch(Exception ex){
				throw new DataAccessException(ex.getMessage());
			}
			
		}
	}
	
	/***
	 * Gets a list of entities by using a where statement
	 * @param query
	 * @param args
	 * @return
	 * @throws DataAccessException
	 */
	protected Collection<T> getFromWhere(String query, Object... args) throws DataAccessException {
		Collection<T> c = new ArrayList<T>();
		
		BeanInfo info;
		try {
			info = Introspector.getBeanInfo(entityClass);
		} catch (IntrospectionException e) {
			throw new DataAccessException(e.getMessage());
		}
		
		PropertyDescriptor[] pds = info.getPropertyDescriptors();
		
		//build statement
		String sql = String.format("Select * from `%s` %s", tableName, query);
		
		/// create statement
		try(PreparedStatement pstmt = getConnection()
				.prepareStatement(sql))
		{
			for(int i = 0; i< args.length;i++) {
				pstmt.setObject(i+1, args[i]);
			}
			
			try(ResultSet rs = pstmt.executeQuery()) {
				while(rs.next()) {
					//create a new instance
					T entity = entityClass.newInstance();
					
					//fetch the meta data
					java.sql.ResultSetMetaData metaData = rs.getMetaData();
					for(int i = 1;i<= metaData.getColumnCount(); i++) {
						Object data = rs.getObject(i);
						
						//skip null values because they are already
						//null in the new object
						if(data == null)
							continue;
						
						String columnName = metaData.getColumnName(i);
						PropertyDescriptor descriptor =Arrays.stream(pds)
								.filter(x -> x.getName().equals(columnName))
								.findFirst().orElse(null);
						if(descriptor != null) {
							if(metaData.getColumnType(i) == Types.DATE  ) {
								//Date handling
								Instant instant = Instant.ofEpochMilli(((Date)data).getTime());
						        data = LocalDateTime.ofInstant(instant, ZoneId.systemDefault()).toLocalDate();
							} else if(metaData.getColumnType(i) == Types.TIMESTAMP  ) {
								//Time handling
								Instant instant = Instant.ofEpochMilli(((Timestamp)data).getTime());
						        data = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());
							}
							//set the property
							descriptor.getWriteMethod().invoke(entity, data);
						}
						
					}
					c.add(entity);
				}
			} 
			return c;
			
		}catch(Exception ex) {
			throw new DataAccessException(ex.getMessage());
		}
	}
	
	/***
	 * Gets the entity by id
	 */
	@Override
	public T get(long id) {
		return getFromWhere("where id = ?",id).stream().findFirst().orElse(null);
	}
	
	/***
	 * Gets all entites
	 */
	@Override
	public Collection<T> getAll() {
		return getFromWhere("");
	}
	
	/***
	 * Deletes an entity
	 */
	@Override
	public void delete(long id) {
		try(PreparedStatement pstmt = getConnection()
				.prepareStatement(String.format("DELETE FROM `%s` where id = ?",tableName))) {
			pstmt.setLong(1,id);
			pstmt.executeUpdate();
		}
		catch(SQLException ex) {
			throw new DataAccessException(ex.getMessage());
		}
	
	}
	
	/***
	 * Property filter used for insert and update statements
	 * These properties are skipped
	 * @return
	 */
	public Collection<String> getPropertyFilter() {
		ArrayList<String> filter= new ArrayList<>();
		filter.add("class");
		filter.add("id");
		return filter;
	}
	
}
