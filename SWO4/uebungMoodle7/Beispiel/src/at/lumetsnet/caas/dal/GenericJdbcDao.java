package at.lumetsnet.caas.dal;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.Closeable;
import java.io.IOException;
import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

import at.lumetsnet.caas.model.Entity;

public abstract class GenericJdbcDao<T extends Entity> implements Closeable, GenericDao<T>   {

	protected Connection con;
	protected String conString;
	protected String userName;
	protected String password;
	protected String tableName;
	protected Class<T> entityClass;
	
	
	
	public GenericJdbcDao(Class<T> entityClass, String tableName, String conString, String userName, String password) {
		this.conString = conString;
		this.userName = userName;
		this.password = password;
		this.tableName = tableName;
		this.entityClass = entityClass;
		
	}

	public Connection getConnection() throws DataAccessException {
		try
		{
			if(con == null) {
				con = DriverManager.getConnection(conString, userName, password);
			}
			return con;
		}
		catch(SQLException ex) {
			throw new DataAccessException(ex.getMessage());
		}
	}
	
	@Override
	public void saveOrUpdate(T entity) {
		if(entity.getId() == -1) {
			try(PreparedStatement stmt = DaoUtil.generateInsertStatement(getConnection(), entity,tableName, getPropertyFilter())) {
				stmt.executeUpdate();
				try(ResultSet rs = stmt.getGeneratedKeys()) {
					if(rs!=null && rs.next()) {
						entity.setId(rs.getInt(1));
					} else {
						throw new DataAccessException("Autogenerated keys are not supported by db");
					}
				}
			} catch(Exception ex){
				throw new DataAccessException(ex.getMessage());
			}
		} else {
			try(PreparedStatement stmt = DaoUtil.generateUpdateStatement(getConnection(), entity,tableName, getPropertyFilter())) {
				stmt.executeUpdate();
			} catch(Exception ex){
				throw new DataAccessException(ex.getMessage());
			}
			
		}
	}
	
	protected Collection<T> getFromWhere(String query, Object... args) throws DataAccessException {
		Collection<T> c = new ArrayList<T>();
		
		BeanInfo info;
		try {
			info = Introspector.getBeanInfo(entityClass);
		} catch (IntrospectionException e) {
			throw new DataAccessException(e.getMessage());
		}
		
		PropertyDescriptor[] pds = info.getPropertyDescriptors();
		
		String sql = String.format("Select * from `%s` %s", tableName, query);
		System.out.println(sql);
		try(PreparedStatement pstmt = getConnection()
				.prepareStatement(sql))
		{
			for(int i = 0; i< args.length;i++) {
				pstmt.setObject(i+1, args[i]);
			}
			
			try(ResultSet rs = pstmt.executeQuery()) {
				while(rs.next()) {
					T entity = entityClass.newInstance();
					java.sql.ResultSetMetaData metaData = rs.getMetaData();
					for(int i = 1;i<= metaData.getColumnCount(); i++) {
						Object data = rs.getObject(i);
						
						if(data == null)
							continue;
						
						String columnName = metaData.getColumnName(i);
						PropertyDescriptor descriptor =Arrays.stream(pds)
								.filter(x -> x.getName().equals(columnName))
								.findFirst().orElse(null);
						if(descriptor != null) {
							if(metaData.getColumnType(i) == Types.DATE  ) {
								Instant instant = Instant.ofEpochMilli(((Date)data).getTime());
						        data = LocalDateTime.ofInstant(instant, ZoneId.systemDefault()).toLocalDate();
							} else if(metaData.getColumnType(i) == Types.TIMESTAMP  ) {
								Instant instant = Instant.ofEpochMilli(((Timestamp)data).getTime());
						        data = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());
							}
							descriptor.getWriteMethod().invoke(entity, data);
						}
						
					}
					c.add(entity);
				}
			} 
			return c;
			
		}catch(Exception ex) {
			throw new DataAccessException(ex.getMessage());
		}
	}
	
	@Override
	public T get(long id) {
		return getFromWhere("where id = ?",id).stream().findFirst().orElse(null);
	}
	
	@Override
	public Collection<T> getAll() {
		return getFromWhere("");
	}
	
	@Override
	public void delete(long id) {
		try(PreparedStatement pstmt = getConnection()
				.prepareStatement(String.format("DELETE FROM `%s` where id = ?",tableName))) {
			pstmt.setLong(1,id);
			pstmt.executeUpdate();
		}
		catch(SQLException ex) {
			throw new DataAccessException(ex.getMessage());
		}
	
	}
	
	@Override
	public void close() throws IOException {
		if(con != null) {
			try {
				con.close();
				con = null;
			} catch (SQLException e) {
				throw new DataAccessException(e.getMessage());
			}
		}
	}
	
	public Collection<String> getPropertyFilter() {
		ArrayList<String> filter= new ArrayList<>();
		filter.add("class");
		filter.add("id");
		return filter;
	}
	
}
